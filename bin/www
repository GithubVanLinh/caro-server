#!/usr/bin/env node

/**
 * Module dependencies.
 */

var app = require("../app");
var debug = require("debug")("socket-caro:server");
var http = require("http");
const { map } = require("../app");
const { get } = require("../routes");

/**
 * Get port from environment and store in Express.
 */

var port = normalizePort(process.env.PORT || "3000");
app.set("port", port);

/**
 * Create HTTP server.
 */

var server = http.createServer(app);
/**
 * Listen on provided port, on all network interfaces.
 */

server.listen(port);
server.on("error", onError);
server.on("listening", onListening);

var io = require("socket.io")(server);

//SOCKET

const room = [
  "room 1",
  "room 2",
  "room 3",
  "room 4",
  "room 5",
  "room 6",
  "room 7",
  "room 8",
  "room 9",
  "room 10",
  "room 11",
  "room 12",
  "room 13",
  "room 14",
  "room 15",
  "room 16",
  "room 17",
  "room 18",
  "room 19",
  "room 20",
];

class Board {
  constructor() {
    this.board = [
      [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
      [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
      [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
      [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
      [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
      [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
      [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
      [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
      [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
      [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
      [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
      [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
      [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
      [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
      [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
      [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
      [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
      [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
      [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
      [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
    ];
  }

  // get board() {
  //   return this.board;
  // }

  /**
   * @param {Number} x x
   * @param {Number} y y
   * @param {Number} value turn
   */
  setBoard(x, y, value) {
    this.board[x][y] = value;
  }

  resetBoard() {
    this.board = [
      [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
      [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
      [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
      [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
      [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
      [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
      [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
      [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
      [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
      [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
      [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
      [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
      [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
      [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
      [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
      [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
      [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
      [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
      [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
      [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
    ];
  }
}

// let Board = [
//   [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
//   [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
//   [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
//   [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
//   [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
//   [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
//   [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
//   [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
//   [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
//   [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
//   [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
//   [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
//   [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
//   [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
//   [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
//   [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
//   [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
//   [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
//   [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
//   [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
// ];

var Arr_Board = {};

function initBoard(params) {
  room.forEach((element) => {
    Arr_Board[element] = new Board();
  });
}

// function game() {
//   console.log("game start!!!");
//   console.log("list gamer:", gamers);
//   io.to(gamers[0]).emit("your_turn", 1);
// }

// function gamestart(io, room) {
//   io.to(room).emit("game-ready");
//   if (socket) {
//     var ready = 0;
//     console.log("Waiting fo Ready...");
//     socket.on("ready", function (mess) {
//       ready++;
//       console.log(ready);
//       if (io.sockets.adapter.rooms.get(room_name).size == 2 && ready == 2) {
//         io.to(room).emit("game-start");

//         var turn = Math.round(Math.random() * 1);
//         var i = 0;
//         io.sockets.adapter.rooms.get(room).forEach((element) => {
//           var soc = io.sockets.sockets.get(element);
//           if (turn == 0) {
//             io.sockets.sockets.get(element).turn = 1;
//             turn++;
//           } else {
//             io.sockets.sockets.get(element).turn = 2;
//             turn--;
//           }
//           soc.emit("your-turn", { turn: soc.turn });
//         });

//         if (socket.turn == 1) {
//           socket.emit("choose-box", { turn: 1 });
//         }

//         // console.log(io.sockets.adapter.rooms.get(room));
//         // console.log(io.sockets.adapter.rooms.get(room));
//         // console.log(io.sockets.adapter.rooms.get(room)[0]);
//         // console.log(io.sockets.adapter.rooms.get(room).get(1));
//       }
//     });

//     socket.on("on-box-click", function ({ x, y, turn }) {
//       console.log(x, y);
//       console.log(Arr_Board);
//       console.log(room);
//       console.log(Arr_Board[room]);
//       Arr_Board[room].setBoard(x, y, turn);
//       if (turn == 1) {
//         socket
//           .to(room)
//           .broadcast.emit("opposite-clicked", { x: x, y: y, turn: 1 });
//         socket.emit("choose-box", { turn: 2 });
//       } else {
//         socket.emit("choose-box", { turn: 1 });
//       }
//     });
//     console.log(socket._events);
//   }
// }
currentTurn = {};
room.forEach(function(room_name) {
  currentTurn[room_name] = 0;
});

initBoard();
io.on("connection", function (socket) {
  console.log(Arr_Board);
  console.log("gamers", io.engine.clientsCount);
  socket.emit("type-your-name");

  socket.on("type-your-name", function (name) {
    socket.name = name;
    console.log(socket.name);

    console.log(socket._events);
    if (socket.name && socket.name.length > 0) {
      socket.on("room-list", function (message, err) {
        if (err) {
          console.log(err);
          return;
        }
        console.log(message);
        socket.emit("room-list", room);

        socket.on("join-room", function (room_name) {
          if (
            !io.sockets.adapter.rooms.get(room_name) ||
            io.sockets.adapter.rooms.get(room_name).size < 2
          ) {
            socket.join(room_name);
            socket.roomName = room_name;
            // socket.leave(socket.id);
            // console.log(socket.rooms);

            // console.log(socket.rooms);
            // console.log(socket.name);

            socket.emit("join-room-success", room_name);

            if (io.sockets.adapter.rooms.get(room_name).size == 2) {
              console.log(`${room_name}: size = 2`);
              io.to(room_name).emit("has-2-player");
              currentTurn[room_name] = 1;

              console.log("set on ready");

              if (io.sockets.adapter.rooms.get(room_name).size == 2) {
                console.log("emit game start");
                io.to(room_name).emit("game-start");
                var turn = Math.round(Math.random() * 1);
                io.sockets.adapter.rooms.get(room_name).forEach((element) => {
                  var soc = io.sockets.sockets.get(element);
                  if (turn == 0) {
                    io.sockets.sockets.get(element).turn = 1;
                    turn++;
                  } else {
                    io.sockets.sockets.get(element).turn = 2;
                    turn--;
                  }
                  soc.emit("your-turn", { turn: soc.turn });
                });

                if (socket.turn == 1) {
                  socket.emit("choose-box", {});
                }
              }
            }
          } else {
            socket.emit("error", { message: `${room_name} was already full` });
          }

          // console.log(io.sockets.adapter.rooms.get(room_name).size); //room size
          // console.log(io.sockets.adapter.rooms.size); //room count

          // console.log(io.sockets.adapter.rooms.get(room));
          // console.log(io.sockets.adapter.rooms.get(room));
          // console.log(io.sockets.adapter.rooms.get(room)[0]);
          // console.log(io.sockets.adapter.rooms.get(room).get(1));
          socket.on("on-box-click", function ({ x, y }) {
            if (currentTurn[socket.roomName] == socket.turn) {
              console.log("on-box-click", "x, y, turn", x, y, socket.turn);

              console.log("on-box-click", "current turn", currentTurn[socket.roomName]);
              Arr_Board[room_name].board[x][y] = socket.turn;
              console.log(Arr_Board[room_name]);

              switch (socket.turn) {
                case 1:
                  currentTurn[socket.roomName] = 2;
                  break;

                case 2:
                  currentTurn[socket.roomName] = 1;
                  break;
                default:
                  break;
              }
              socket.to(room_name).broadcast.emit("choose-box", {
                x: x,
                y: y,
                turn: socket.turn,
              });
            } else {
              socket.emit("error", { message: "Not your turn" });
            }
          });

          console.log(socket._events);
        });
      });
    }
  });

  // gamers.push(socket.id);
  // if (io.engine.clientsCount == 2) {
  //   game();
  // }

  // socket.on("disconnect", function () {
  //   console.log("a log out gamers:", io.engine.clientsCount);
  //   console.log(socket.id);
  //   const pos = gamers.indexOf(socket.id);
  //   console.log(pos);
  //   gamers.splice(pos, 1);
  //   console.log(gamers);
  // });

  // socket.on("client-send-data", function (playerTurn, cell, mX, mY) {
  //   console.log(
  //     "playerTurn= " +
  //       playerTurn +
  //       ", cell= " +
  //       cell +
  //       ", mX= " +
  //       mX +
  //       ", mY= " +
  //       mY
  //   );

  //   socket.broadcast.emit("server-send-data", {
  //     playerTurn: playerTurn,
  // 		cell:cell,
  //     mX: mX,
  //     mY: mY,

  //   });
  //   // io.emit('server-send-data',{
  //   // 	playerTurn:playerTurn,
  //   // 	mX:mX,
  //   // 	mY:mY
  //   // });
  // });
  // socket.on("client-send-result",function(number,result,ResultDefine){
  // 	console.log("number= "+number+", result= "+result);
  // 	socket.broadcast.emit("server-send-result", {
  //     number:number,
  // 		result:result,
  //     ResultDefine:ResultDefine
  //   });
  // });
  // socket.on("client-send-new-game",function(your_turn){
  //   console.log("new game, your_turn = "+your_turn);
  // });
});
/**
 * Normalize a port into a number, string, or false.
 */

function normalizePort(val) {
  var port = parseInt(val, 10);

  if (isNaN(port)) {
    // named pipe
    return val;
  }

  if (port >= 0) {
    // port number
    return port;
  }

  return false;
}

/**
 * Event listener for HTTP server "error" event.
 */

function onError(error) {
  if (error.syscall !== "listen") {
    throw error;
  }

  var bind = typeof port === "string" ? "Pipe " + port : "Port " + port;

  // handle specific listen errors with friendly messages
  switch (error.code) {
    case "EACCES":
      console.error(bind + " requires elevated privileges");
      process.exit(1);
      break;
    case "EADDRINUSE":
      console.error(bind + " is already in use");
      process.exit(1);
      break;
    default:
      throw error;
  }
}

/**
 * Event listener for HTTP server "listening" event.
 */

function onListening() {
  var addr = server.address();
  var bind = typeof addr === "string" ? "pipe " + addr : "port " + addr.port;
  debug("Listening on " + bind);
}
